
JIT 编译器， 将代码编译成机器码
https://juejin.cn/post/6844904137792962567
什么是v8:
 javascript引擎
 产生的目的就是为了提高性能。 更快速的解析和执行JavaScript代码
V8编译过程:
 1. script类通过编译器类生成抽象语法树以及获取最终生成的本地代码
 2. 调用parser类生成抽象语法树
 3. 通过抽象语法节点工厂生成节点
 4. 分配内存
 5. 遍历抽象语法树
 6. 生成本地代码
 7. 获取本地代码

V8运行过程:
 1. 运行JSFunction运行本地代码，构建js对象，写入内存
 2. 使用Runtime类创建对象，并完成一些功能，
 3. 期间会进行垃圾回收

AST抽象语法树

无论使用什么编程语言（无论是解释形语言还是编译形语言）都会将源代码解析成 抽象语法树

V8 AST编译过程
 1. 原始代码
 2. scanner解析器进行解析 （tokens）
 3. parser生成AST 并进行优化
 4. Lgnition生成字节码

注: scanner最重要的功能就是将js源码转换成一个个有意义的词（token）形成的数组
    语法分析parser 

V8引擎通常会经过一下流程：源码 --> AST --> 字节码 --> 二进制代码
 1. BytecodeGenerator类 将 ast 转换成 字节码 
 2. 字节码是机器码的抽象

内联缓存 「优化策略」

内存结构
堆空间的结构
 1. 新生代内存区（new space） 新生代会有两个semispace， 每个semispace 默认大小为16MB，也就是说新生代通常只有32m 64位， 两个semispace 分别是fromspace tospace 都有两个状态 工作状态 空闲状态  当一个为工作状态的时候另一个一定是空闲状态。
 2. 老生代内存区（old space）分为 old pointer space 和old data space 用来存 gc后的指针和数据
 3. 大对象区 存放体积超越其他区的对象，主要是避免大对象的拷贝，专门存储大对象
 4. 单元区、属性单元区、Map区 == cell space、 property cell space 、 map space 
    map空间大小为 8MB
 5. 代码区 (code Space) 存放代码对象 最大 大小为 512MB 唯一拥有执行权限的内存

内存运行的生命周期

这里我们假设创建了一个对象 obj，先说一下新生代内存区的两个space也就是 from space 和 to space 的作用。

首先obj会被分配到 新生代 中两个space中其中一个space，这里我们假设分配到了from space中。
程序继续执行会不断的向from space中添加新的对象信息，这时from space将要达到了存储的上限（16MB），V8的垃圾回收机制会开始清理from中不再被使用的对象（即没有被指向的对象）。
清理后，将所有仍然存活的对象（我们假设obj还存活），会被复制到to space然后删除所有from space中的对象。
这时，程序继续运行，如果有新创建的对象会不断的分配到to space中，当to space快要满了重复执行上面说的复制转移的工作。

也就是说创建的对象会在to space 和 from space 之间转移，也就是所谓的 to --> from, from --> to 的角色互换过程。
  接下来说一下老生代内存区，现在继续看上文说的那个对象 obj：

经过程序一段时间运行后的obj依然存活在新生代内存区，终于满足了晋升的条件，便转移到了老生代内存区。
又过了一段时间对象 obj 终于不被引用了，同时老生代内存区域空间也被占用了很多的空间，V8就会在老生代里面进行遍历，发现了对象 obj 已经不被引用了，于是给他打了个标记。
由于V8是单线程的执行机制，V8为了避免一次清除占用太多时间，会给这批打了标记的待清理对象进行分批回收，至此这个对象就在内存中释放掉了

v8在执行代码的时候
当遇到函数的情况下，会创建一个函数执行上下文，并添加到调用栈的栈顶，函数的作用域 handlescope 中包含了所有该函数声明的变量，函数执行完毕之后，对应的执行上下文从栈顶弹出，函数的作用域也会被销毁，其中包含的所有变量会被统一释放并被自动回收。 如果内存堆积引发内存泄漏 程序性能就会持续下降，甚至崩溃

垃圾回收机制

  副垃圾回收器 负责新生代区域的垃圾回收
  主垃圾回收器 负责老生代区域的垃圾回收

创建一个对象
  1. 会向内存堆中的新生代去分配，假如此时新生代中的from spcae 是工作状态，那么对象会分配到from space 中。
经过一段时间程序运行，from space的的内存即将达到存储的上限。

  2. V8引擎此时执行一次垃圾清理操作，会将from space中不再使用的对象（根节点无法遍历到的对象）进行标记。

  3. 会将未被标记的对象进行复制，复制到空闲状态的to space中并且有序的重新排列起来，再将from space进行清空操作，同时将from space 标记为空闲状态将to space标记为工作状态。

晋升机制的条件： 什么时候会把对象放到老生代
 经历过一次Scavenging算法，且并未被标记清除的，也就是过一次翻转置换操作 （from -> to ）的对象。
 在进行翻转置换时，被复制的对象大于to space空间的25%。(from space 和 to space 一定是一样大的)

主垃圾回收器(Mark-Sweep & Mark-Compact)

  主垃圾回收器采用的方法和次垃圾回收器的方法完全不同，主垃圾回收器会先使用标记 - 清除（Mark-Sweep）的算法进行垃圾回收。

  首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

  接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会直接将标记为垃圾的数据清理掉。


  标记 - 整理（Mark-Compact） 算法主要也是分两步：
  首先同样是标记过程。
  将未标记的对象（存活对象）进行左移，移动完成后清理边界外的内存。


