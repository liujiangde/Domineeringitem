
JIT 编译器， 将代码编译成机器码
https://juejin.cn/post/6844904137792962567
什么是v8:
 javascript引擎
 产生的目的就是为了提高性能。 更快速的解析和执行JavaScript代码
V8编译过程:
 1. script类通过编译器类生成抽象语法树以及获取最终生成的本地代码
 2. 调用parser类生成抽象语法树
 3. 通过抽象语法节点工厂生成节点
 4. 分配内存
 5. 遍历抽象语法树
 6. 生成本地代码
 7. 获取本地代码

V8运行过程:
 1. 运行JSFunction运行本地代码，构建js对象，写入内存
 2. 使用Runtime类创建对象，并完成一些功能，
 3. 期间会进行垃圾回收

AST抽象语法树

无论使用什么编程语言（无论是解释形语言还是编译形语言）都会将源代码解析成 抽象语法树

V8 AST编译过程
 1. 原始代码
 2. scanner解析器进行解析 （tokens）
 3. parser生成AST 并进行优化
 4. Lgnition生成字节码

注: scanner最重要的功能就是将js源码转换成一个个有意义的词（token）形成的数组
    语法分析parser 

V8引擎通常会经过一下流程：源码 --> AST --> 字节码 --> 二进制代码
 1. BytecodeGenerator类 将 ast 转换成 字节码 
 2. 字节码是机器码的抽象

内联缓存 「优化策略」

内存结构
堆空间的结构
 1. 新生代内存区（new space） 新生代会有两个semispace， 每个semispace 默认大小为16MB，也就是说新生代通常只有32m 64位， 两个semispace 分别是fromspace tospace 都有两个状态 工作状态 空闲状态  当一个为工作状态的时候另一个一定是空闲状态。
 2. 老生代内存区（old space）分为 old pointer space 和old data space 用来存 gc后的指针和数据
 3. 大对象区 存放体积超越其他区的对象，主要是避免大对象的拷贝，专门存储大对象
 4. 单元区、属性单元区、Map区 == cell space、 property cell space 、 map space 
    map空间大小为 8MB
 5. 代码区 (code Space) 存放代码对象 最大 大小为 512MB 唯一拥有执行权限的内存

内存运行的生命周期

这里我们假设创建了一个对象 obj，先说一下新生代内存区的两个space也就是 from space 和 to space 的作用。

首先obj会被分配到 新生代 中两个space中其中一个space，这里我们假设分配到了from space中。
程序继续执行会不断的向from space中添加新的对象信息，这时from space将要达到了存储的上限（16MB），V8的垃圾回收机制会开始清理from中不再被使用的对象（即没有被指向的对象）。
清理后，将所有仍然存活的对象（我们假设obj还存活），会被复制到to space然后删除所有from space中的对象。
这时，程序继续运行，如果有新创建的对象会不断的分配到to space中，当to space快要满了重复执行上面说的复制转移的工作。

也就是说创建的对象会在to space 和 from space 之间转移，也就是所谓的 to --> from, from --> to 的角色互换过程。
  接下来说一下老生代内存区，现在继续看上文说的那个对象 obj：

经过程序一段时间运行后的obj依然存活在新生代内存区，终于满足了晋升的条件，便转移到了老生代内存区。
又过了一段时间对象 obj 终于不被引用了，同时老生代内存区域空间也被占用了很多的空间，V8就会在老生代里面进行遍历，发现了对象 obj 已经不被引用了，于是给他打了个标记。
由于V8是单线程的执行机制，V8为了避免一次清除占用太多时间，会给这批打了标记的待清理对象进行分批回收，至此这个对象就在内存中释放掉了

v8在执行代码的时候
当遇到函数的情况下，会创建一个函数执行上下文，并添加到调用栈的栈顶，函数的作用域 handlescope 中包含了所有该函数声明的变量，函数执行完毕之后，对应的执行上下文从栈顶弹出，函数的作用域也会被销毁，其中包含的所有变量会被统一释放并被自动回收。 如果内存堆积引发内存泄漏 程序性能就会持续下降，甚至崩溃

垃圾回收机制

  副垃圾回收器 负责新生代区域的垃圾回收
  主垃圾回收器 负责老生代区域的垃圾回收

副垃圾回收器(Scavenging)

创建一个对象
  1. 会向内存堆中的新生代去分配，假如此时新生代中的from spcae 是工作状态，那么对象会分配到from space 中。
经过一段时间程序运行，from space的的内存即将达到存储的上限。

  2. V8引擎此时执行一次垃圾清理操作，会将from space中不再使用的对象（根节点无法遍历到的对象）进行标记。

  3. 会将未被标记的对象进行复制，复制到空闲状态的to space中并且有序的重新排列起来，再将from space进行清空操作，同时将from space 标记为空闲状态将to space标记为工作状态。

晋升机制的条件： 什么时候会把对象放到老生代
 经历过一次Scavenging算法，且并未被标记清除的，也就是过一次翻转置换操作 （from -> to ）的对象。
 在进行翻转置换时，被复制的对象大于to space空间的25%。(from space 和 to space 一定是一样大的)

主垃圾回收器(Mark-Sweep & Mark-Compact)

  主垃圾回收器采用的方法和次垃圾回收器的方法完全不同，主垃圾回收器会先使用标记 - 清除（Mark-Sweep）的算法进行垃圾回收。

  首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

  接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会直接将标记为垃圾的数据清理掉。


  标记 - 整理（Mark-Compact） 算法主要也是分两步：
  1. 首先同样是标记过程。
  2. 将未标记的对象（存活对象）进行左移，移动完成后清理边界外的内存。

垃圾回收优化策略（Orinoco）

一个垃圾回收机制好坏的一个重要标准是取决于执行垃圾回收时主线程挂起的时间，
V8 为了减少主线程挂起的时间 启动了代号Orinoco的垃圾回收器项目专门来进行垃圾回收策略的优化

Orinoco共实现了三个优化
1. 并行垃圾回收 parallel
  · 开启多个线程，有依赖关系的垃圾清理逻辑（不止上述一种）通过并行执行的方式来优化减少执行垃圾回收占用主进程的时间
2. 增量垃圾回收 incremental
  · 将一次大的任务分解为更小的块，允许应用程序在块之间运行
  · 于是V8采用了 标记位 和 标记工作表 来实现标记。标记位用来标记三种颜色：白色(00)、灰色(10)、黑色(11)，
  · 
3. 并发垃圾回收 cuncurrent
  · 并 行 垃圾回收发生在主线程和工作线程上。应用程序在整个并行标记阶段暂停。
    并 发 垃圾回收主要发生在工作线程上。当并发垃圾回收正在进行时，应用程序可以继续运行。

空闲时垃圾回收：空闲时垃圾回收并不属于Orinoco项目，是V8实现的一种优化策略。



V8 为什么要设置新生代和老生代
  1. 为了实现更高效的垃圾回收机制
  2. 新生代中的对象在创建后很快就会被销毁，因此垃圾回收的频率也很高。为了避免对整个堆内存进行扫描，V8使用了基于复制的垃圾回收算法。



消息队列

消息队列可以和多种异步场景产生交互。
1. 输入事件相关的异步交互（比如onClick）由引擎的 DOM Binding 模块处理，相应的事件触发时，会将对应的回调函数添加到消息队列中。
2. ajax请求相关的异步交互 由引擎的network模块处理，在网络请求完成返回之后，会将对应的回调函数添加到消息队列中。
3. 定时器相关的异步交互 会引擎的 timer 模块处理，当时间到达的时候，会将回调函数添加到任务队列中。（定时器调度策略比较复杂，会有专门的调度策略在合适的时间添加对应的回调任务）


宏任务 微任务
在JavaScript中，任务可以分为宏任务（Macro Task）和微任务（Micro Task）。

宏任务通常是指由浏览器或Node.js环境提供的任务，比如DOM事件、setTimeout、setInterval、setImmediate（Node.js中）、I/O操作等等。当一个宏任务完成后，JavaScript引擎会检查是否有微任务需要执行，如果有，则会立即执行所有微任务，然后再开始下一个宏任务。

微任务则是指在当前任务执行结束后需要立即执行的任务，比如Promise中的then、catch、finally方法，MutationObserver的回调函数等等。微任务通常是由宿主环境（浏览器或Node.js）自行处理的，JavaScript引擎只需等待宿主环境通知即可。

具体来说，当一个宏任务执行过程中产生了微任务，这些微任务会被放到一个队列中，等待当前宏任务执行完毕后立即执行。如果在执行这些微任务的过程中，又产生了新的微任务，那么这些新的微任务也会被放到队列中，直到队列中的所有微任务都执行完毕为止。只有当所有微任务都执行完毕后，JavaScript引擎才会开始执行下一个宏任务。

简而言之，宏任务是由宿主环境提供的任务，微任务是在当前任务执行结束后需要立即执行的任务，执行顺序是先微任务后宏任务。

在浏览器环境中，常见的宏任务有：
script（整体代码）
setTimeout
setInterval
I/O 操作
UI 交互事件（如点击、滚动等）
postMessage
requestAnimationFrame
页面生命周期事件（如DOMContentLoaded、load等）
常见的微任务有：

Promise 的 then、catch、finally 方法
async/await
process.nextTick（Node.js环境中）
MutationObserver（监测 DOM 变化）
需要注意的是，虽然 Promise 是微任务，但它的构造函数中的代码是宏任务。另外，由于 Promise 构造函数中的代码也可能会产生微任务，因此 Promise 构造函数中的代码可能会在当前宏任务执行完毕后立即执行。