web缓存：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存

缓存 - 浏览器缓存里的http缓存。
为什么要缓存
1. 减少了冗余的数据传输，节省了网络费用
2. 缓解了网络瓶颈的问题，不需要更多的带宽就能更快的加载页面
3. 降低了对原始服务器的需求，服务器可以更快地响应，有效避免过载
4. 降低距离时延，因为距离服务器远的地方加载页面会慢一点
   
纵览缓存处理步骤

1. 接收 缓存从网络中读取抵达的网络报文
2. 解析 缓存对报文进行解析 提取出url 和各种首部
    解析程序还要负责首部各个部分的标准化， 将大小写或者可替换的数据格式之类不太重要的区别看做是等效的
    某些请求报文中有绝对Url，而其他一些请求中包含的则是相对URL和host首部，解析程序通常需要将他们隐藏起来
3. 查询 缓存查看本地是否有副本可以用，如果没有，就获取一份副本保存在本地
4. 新鲜度检测 缓存查看当前缓存副本是否新鲜「查看已缓存的副本是否超过了新鲜度限值(freshness limit)」，如果不是， 就询问服务器是否有更新
5. 创建响应 缓存会用新的首部和已缓存的主体来构建一条响应报文
6. 发送 缓存通过网络将响应发回给客户端
7. 日志 缓存可选地创建一个日志文件条目来描述这个事务 


强缓存

通过 cache-control 和 expires HTTP 让原始服务器向 每个文档附加了一个“过期日期”
 HTTP/1.0+ 的 Expires 首部或 HTTP/1.1 的 Cache-Control: max-age 响应首 部来指定过期日期
 expires 和 cache-control 的 max-age 所做的事情本质上是一样的  Cache-Control优先级更高。

服务器再验证
  1. 如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。
  2. 如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。 


  Cache-Control：
    no-store 禁止一切缓存

    no-cache 强制客户端直接向服务器发送请求 判断资源是否变更，是则返回新内容，否则返回304，未变更
              只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。

    max-age  从服务器将文档传来之时起，可以认为此 文档处于新鲜状态的秒数。

    s-maxage 和max-age是一样的，不过它只针对代理服务器缓存而言。

    private 只能针对个人用户，而不能被代理服务器缓存

    public 可以被任何对象缓存，包括发送请求的客户端，代理服务器。





？？？ 当前http请求状态为 304 的时候 请求头会出现 if-modified-since 和 if-none-Match
强缓存 和协商缓存两者之间比较明显的区别
1. 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。
2. 在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。 不同浏览器的策略不同，在 Fire Fox中，from cache 状态码是 304.


我的项目中 

文档请求（html）请求接口是304 ，并且 请求头里面有if-modified-since 和 if-none-match 字段

js「请求是预配表头」 css「没有请求头」 图片：「请求是预配表头」 字体：「请求是预配表头」
 这些资源请求是200 走的是内存缓存
？？？可能得原因 文档中的script引入的脚本文件发生了变化 但是比较了200 和304 的接口返回，内容都一模一样




？？？ 浏览器默认是协商缓存