2021 年前端性能清单
Front-End Performance Checklist 2021
Below you’ll find an overview of the front-end performance issues you might
need to consider to ensure that your response times are fast and smooth.
____

Get Ready: Planning and Metrics
☐ Establish a performance culture.
As long as there is no business buy-in, performance isn’t going to sustain long-term. Study
common complaints coming into customer service and see how improving performance can
help relieve some of these problems. Build up a company-tailored case study with real data
and business metrics. Plan out a loading sequence and trade-offs during the design process.

☐ Be 20% faster than your fastest competitor.
Gather data on a device representative of your audience. Prefer real devices to simulations.
Choose a Moto G4/G5 Plus, a mid-range Samsung device (Galaxy A50, S8), a good middle-ofthe-road device like a Nexus 5X, Xiaomi Mi A3 or Xiaomi Redmi Note 7 and a slow device like
Alcatel 1X or Cubot X19. Alternatively, emulate mobile experience on desktop by testing on a
throttled network (e.g. 300ms RTT, 1.6 Mbps down, 0.8 Mbps up) with a throttled CPU (5×
slowdown). Then switch over to regular 3G, slow 4G (e.g. 170ms RTT, 9 Mbps down, 9 Mbps
up), and Wi-Fi. Collect data, set up a spreadsheet, shave off 20%, and set up your goals
(performance budgets).

☐ Choose the right metrics.
Not every metric is equally important. Study what metrics matter most: usually it will be
related to how fast you can start render most important pixels and how quickly you can provide
input responsiveness. Prioritize page loading as perceived by your customers. Time to
Interactive, First Input Delay, Hero Rendering Times, Largest Contentful Paint, Total Blocking
Time and Cumulative Layout Shift usually matter. Not: First Meaningful Paint.

☐ Set up "clean" and "customer" profiles for testing.
Turn off anti-virus and background CPU tasks, remove background bandwidth transfers and
test with a clean user profile without browser extensions to avoid skewed results. Study
which extensions your customers use, and test with a dedicated "customer" profile as well.
Curated by Vitaly Friedman. Permanent URL: www.smashed.by/perf-checklist. January 11, 2021.

☐ Share the checklist with your colleagues.
Make sure that the checklist is familiar to every member of your team. Every decision has
performance implications, and your project would hugely benefit from distributing
ownership across the entire team. Map design decisions against the performance budget.

Setting Realistic Goals
☐ 100-millisecond response time, 60 frames per second.
Each frame of animation should complete in less than 16 milliseconds — ideally 10
milliseconds, thereby achieving 60 frames per second (1 second ÷ 60 = 16.6 milliseconds). Be
optimistic and use the idle time wisely. For high pressure points like animation, it’s best to do
nothing else where you can and the absolute minimum where you can’t. Estimated Input
Latency should be below 50ms. Use idle time wisely, with the Idle Until Urgent approach.

☐ LCP < 2.5s, FID < 100ms, CLS < 0.1, Time To Interactive < 5s on 3G.
Considering the baseline being a $200 Android phone on a slow 3G, emulated at 400ms RTT
and 400kbps transfer speed, aim for Time to Interactive < 5s, and for repeat visits, under 2–3s.
Aim for Largest Contentful Paint < 2.5s and minimize Total Blocking Time and Cumulative Layout
Shift. Put your effort into getting these values as low as possible.

☐ Critical file size budget < 170KB
The first 14–16KB of the HTML is the most critical payload chunk — and the only part of the
budget that can be delivered in the first roundtrip. To achieve goals stated above, operate
within a critical file size budget of max. 170KB gzipped (0.7-0.8MB decompressed. Make sure
your budgets change based on network conditions and hardware limitations.

Defining the Environment
☐ Choose and set up your build tools.
Don’t pay much attention to what’s supposedly cool. As long as you are getting results fast and
you have no issues maintaining your build process, you’re doing just fine. The only exception
might be Webpack or Parcel which provide useful optimization techniques such as codesplitting. If it’s not in use yet, make sure to look in detail into code-splitting and tree-shaking.

☐ Use progressive enhancement as a default.
Design and build the core experience first, and then enhance the experience with advanced
features for capable browsers, creating resilient experiences. If your website runs fast on a

slow machine with a poor screen in a poor browser on a suboptimal network, then it will only
run faster on a fast machine with a good browser on a decent network.

☐ Choose a strong performance baseline.
JavaScript has the heaviest cost of the experience. With a 170KB budget that already contains
the critical-path HTML/CSS/JavaScript, router, state management, utilities, framework and
the app logic, thoroughly examine network transfer cost, the parse/compile time and the
runtime cost of the framework of our choice.

☐ Evaluate each framework and each dependency.
Not every project needs a framework, not every page of a SPA needs to load the framework. Be
deliberate in your choices. Evaluate third-party JS by exploring features, accessibility, stability,
performance, package ecosystem, learning curve, documentation, tooling, track record, team,
compatibility and security. Next.js (React), Gatsby (React), Vuepress (Vue) and Preact
CLI provide reasonable defaults for fast loading out of the box on average mobile hardware.

☐ Pick your battles wisely: React, Vue, Angular, Ember and Co.
Make sure that the framework of your choice provides server-side rendering or prerendering.
Measure boot times in server- and client-rendered modes on mobile devices before deciding.
Understand the nuts and bolts of the framework you’ll be relying on. Look into PRPL pattern
and app shell architecture. Notable options are Preact, Inferno, Vue, Svelte, Alpine, Polymer.

☐ Optimize the performance of your APIs.
If many resources require data from an API, the API might become a performance bottleneck.
Consider using GraphQL, a query language and a server-side runtime for executing queries by
using a type system you define for your data. Unlike REST, GraphQL can retrieve all data in a
single request, without over or under-fetching data as it typically happens with REST.

☐ Will you be using AMP or Instant Articles?
You can achieve good performance without them, but AMP might provide a solid performance
framework, with a free CDN, while Instant Articles will boost your visibility and performance
on Facebook. You could build progressive web AMPs, too.

☐ Choose your CDN wisely.
Depending on how much dynamic data you have, you might be able to “outsource” some part
of the content to a static site generator, push it to a CDN and serve a static version from it,
thus avoiding database requests (JAMStack). Double-check that your CDN performs content
compression and conversion, (e.g. image optimization in terms of formats, compression and
resizing at the edge), support for servers workers and edge-side includes for you.

Assets Optimizations
☐ Use Brotli for plain text compression.
Brotli, a new lossless data format, is now supported in all modern browsers. It’s more effective
than Gzip and Deflate, compresses very slowly, but decompresses fast. Pre-compress static
assets with Brotli+Gzip at the highest level, compress (dynamic) HTML on the fly with Brotli
at level 1–4. Check for Brotli support on CDNs, too. Make sure that the server handles content
negotiation for Brotli or gzip properly.

☐ Use responsive images, AVIF and WebP.
As far as possible, use responsive images with srcset, sizes, <picture> and image-set. AVIF > WebP.
Serve AVIF and WebP formats with <picture> and a JPEG/PNG fallback, or by using content
negotiation (using Accept headers). Note: with WebP, you'll reduce the payload, but with JPEG
you'll improve perceived performance, so users might see an actual image faster with a good
ol' JPEG although WebP images might get faster through the network.

☐ Are images properly optimized?
Use mozJPEG for JPEG compression, SVGO for SVG compression, Pingo for PNGs — or Squoosh
for all of them (incl. AVIF). To check the efficiency of your responsive markup, you can
use imaging-heap. For critical images, use progressive JPEGs and blur out unnecessary parts
(by applying a Gaussian blur filter) and remove contrast (you can reapply it with CSS filters).
Make sure width and height are defined for all images, add automatic image compression to
your pull requests and look into lazy loading less critical images.

☐ Are videos properly optimized?
Instead of animated GIFs, use either animated WebP (with GIF being a fallback) or looping
inlined HTML5 videos. Make sure that your MP4s are processed with a multipass-encoding,
blurred with the frei0r iirblur eﬀect (if applicable) and moov atom metadata is moved to the head
of the file, while your server accepts byte serving. Whenever possible, serve the video in AV1
format, but provide a fallback as well. Resize videos and use adaptive media serving to provide
the content that your customers can actually play without stalls on their devices.

☐ Are web fonts optimized?
Subset the fonts. Prefer WOFF2 and use WOFF as fallback. Display content in the fallback
fonts right away, load fonts async, then switch the fonts, in that order. Ultimate solution: twostage render, with a small supersubset first, and the rest of the family loaded async later.
Preload 1–2 fonts of each family. Avoid the local() value for font declarations, but consider
locally installed OS fonts. Don't forget to include font-display: optional and use Font Load Events
for group repaints. Use Web Font Reflow Count and Time To Real Italics metrics.

Build Optimizations
☐ Set your priorities right.
Run an inventory on all of your assets (JavaScript, images, fonts, third-party scripts,
“expensive” modules on the page), and break them down in groups. Define the basic core
experience (fully accessible core content for legacy browsers), the enhanced experience (an
enriched, full experience for capable browsers) and the extras (assets that aren’t absolutely
required and that can be lazy-loaded).

☐ Use native JavaScript modules in production.
Send the core experience to legacy browsers and an enhanced experience to modern browsers.
Use ES2017+ <script type="module"> for loading JavaScript: modern browsers will interpret the
script as a JavaScript module and run it as expected, while legacy browsers wouldn't recognize
it and hence ignore it.

☐ Executing JavaScript is expensive, so tame it.
With SPAs, you might need some time to initialize the app before you can render the page.
Look for modules and techniques to speed up the initial rendering time, e.g. with progressive
hydration and import on interaction (times are 2–5x times higher on low-end mobile devices).

☐ Use tree-shaking, scope hoisting and code-splitting to reduce payloads.
Tree-shaking is a way to clean up your build process by only including code that is actually
used in production. Code-splitting splits your code base into “chunks” that are loaded on
demand. Scope hoisting detects where import chaining can be flattened and converted into
one inlined function without compromising the code (e.g. via Webpack). Use granular
chunking and offload some of the client-side rendering to the server. Define split points by
tracking which CSS/JS chunks are used, and which aren’t. Consider code-splitting at the
package level as well.

☐ Can you offload JavaScript into a Web Worker or WebAssembly?
As the code base evolves, UI performance bottlenecks will start showing up. It happens
because DOM operations are running alongside your JS on the main thread. Consider moving
these expensive operations to a background process that’s running on a different thread with
web workers. Typical use case: prefetching data and PWAs. Consider offloading
computationally heavy tasks off to WebAssembly, which works best for computationally
intensive web apps, such as games.

☐ Serve legacy code only to legacy browsers (differential serving).
Use babel-preset-env to only transpile ES2017+ features unsupported by the modern browsers
you are targeting. Then set up two builds, one for modern, and one for legacy browsers. For

lodash, use babel-plugin-lodash that will load only modules that you are using in your source.
Transform generic lodash requires to cherry-picked ones to avoid code duplication. Use the
header <link rel="modulepreload"> to initiate early (and high-priority) loading of module scripts.

☐ Identify and rewrite legacy code with incremental decoupling.
Revisit your dependencies and assess how much time would be required to refactor or rewrite
legacy code that has been causing trouble lately. First, set up metrics that tracks if the ratio of
legacy code calls is staying constant or going down, not up. Publicly discourage the team from
using the library and make sure that your CI alerts developers if it's used in pull requests.

☐ Identify and remove unused CSS/JavaScript.
CSS and JavaScript code coverage in Chrome allows you to learn which code has been
executed/applied and which hasn’t. Once you've detected unused code, find those modules
and lazy load with import(). Then repeat the coverage profile and validate that it's now
shipping less code on initial load. Use Puppeteer to programmatically collect code coverage.

☐ Trim the size of your JavaScript dependencies.
There’s a high chance you’re shipping full JavaScript libraries when you only need a fraction.
To avoid the overhead, consider using webpack-libs-optimizations that removes unused methods
and polyfills during the build process. Add bundle auditing into your regular workflow.
Bundlephobia helps find the cost of adding an npm package to your bundle, size-limit extends
basic bundle size check with details on JavaScript execution time. Use Skypack to discover
community-curated packages with focus on quality and performance.

☐ Are you using predictive prefetching for JavaScript chunks?
Use heuristics to decide when to preload JavaScript chunks. Guess.js is a set of tools that use
Google Analytics data to determine which page a user is mostly likely to visit next. Also,
consider Quicklink, Instant.page and DNStradamus. Note: you might be prompting the browser
to consume unneeded data and prefetch undesirable pages, so it's a good idea to be quite
conservative in the number of prefetched requests.

☐ Optimize for your target JavaScript engines.
Make use of script streaming for monolithic scripts, so they can be parsed on a separate
background thread once downloading begins. Hook into V8’s code caching as well, by splitting
out libraries from code using them, or the other way around. Consider JIT Optimization
Strategies for Firefox’s Baseline Interpeter as well.

☐ Find a way to marry client-side rendering and server-side rendering.
Usually the goal is to find the optimum balance between client-side and server-side rendering.
Consider prerendering if your pages don't change much, and defer the booting of frameworks

if you can. Stream HTML in chunks with server-side rendering, and implement progressive
hydration for individual components with client-side rendering — and hydrate on visibility,
interaction or during idle time to get the best of both worlds. (Streaming Server-Side Rendering
With Progressive Hydration).

☐ Consider micro-optimizations and progressive booting.
Use server-side rendering to get a quick first meaningful paint, but also include some
minimal JS to keep the time-to-interactive close to the first meaningful paint. Then, either on
demand or as time allows, boot non-essential parts of the app. Always break up the execution
of functions into separate, asynchronous tasks. Where possible use requestIdleCallback.

☐ Always self-host third-party assets.
Using a public CDN will not automatically lead to better performance. Even if two sites point
to the exact same third party resource URL, the code is downloaded once per domain, and the
cache is "sandboxed" to that domain. First-party assets are more likely to stay in the cache
than third-party assets. Self-hosting is more reliable, secure, and better for performance.

☐ Constrain the impact of third-party scripts.
Too often one single third-party script ends up calling a long tail of scripts. Consider using
service workers by racing the resource download with a timeout. Establish a Content Security
Policy (CSP) to restrict the impact of third-party scripts, e.g. disallowing the download of audio
or video. Embed scripts via iframe, so scripts don't have access to the DOM. Sandbox them, too.
To stress-test scripts, examine bottom-up summaries in Performance profile page (DevTools).
Load third-party scripts only once the app has initialized. Watch out for anti-flicker snippets.

☐ Set HTTP cache headers properly.
Double-check that expires, cache-control, max-age and other HTTP cache headers are set
properly. In general, resources should be cacheable either for a very short time (if they are
likely to change) or indefinitely (if they are static). Use cache-control: immutable to avoid
revalidation. Check that you aren’t sending unnecessary headers (e.g. x-powered-by, pragma, xua-compatible, expires). Make use of zero RTT for repeat views via stale-while-revalidate.

Delivery Optimizations
☐ Load JavaScript asynchronously.
As developers, we have to explicitly tell the browser not to wait and to start rendering the page
with the defer and async attributes in HTML. Always prefer defer to async. With defer, browser
doesn't execute scripts until HTML is parsed and all prior sync scripts have executed. Don’t
use both. Unless you need JS to execute before start render, it's better to use defer.

☐ Lazy load expensive components with IntersectionObserver.
Lazy-load all expensive components, such as heavy JavaScript, videos, iframes, widgets, and
potentially images. The most performant way to do so is either with native lazy-loading
(loading and importance attributes) or by using the Intersection Observer — the latter can be
used for performant scrollytelling, parallax and ads tracking as well.

☐ Defer rendering and decoding for expensive images.
With content-visibility: auto, we can prompt the browser to skip the layout of the children while
the container is outside of the viewport. Just make sure to use contain-intrinsic-size with a
placeholder properly sized to avoid CLS. Also, prompt the browser to decode the image off the
main thread with <img decoding=“async”>, to reduce CPU-time needed for the operation.

☐ Push critical CSS quickly.
Collect all of the CSS required to start rendering the first visible portion of the page (“critical
CSS” or “above-the-fold” CSS), and add it inline in the <head> of the page (stay under 14 KB).
Consider the conditional inlining approach. Putting critical CSS in a separate file on the root
domain has benefits, sometimes more than inlining due to caching.

☐ Experiment with regrouping your CSS rules.
Consider splitting the main CSS file out into its individual media queries. Avoid placing <link
rel="stylesheet" /> before async snippets. If scripts don’t depend on stylesheets, consider placing
blocking scripts above blocking styles. If they do, split that JavaScript in two and load it either
side of your CSS. Cache inlined CSS with a service worker and experiment with in-body CSS.
Dynamic styling can be expensive: check that your CSS-in-JS library optimizes the execution
when your CSS has no dependencies on theme/props, don't over-compose styled components.

☐ Stream responses.
Streams provide an interface for reading or writing asynchronous chunks of data, only a
subset of which might be available in memory at any given time. Instead of serving an empty
UI shell and letting JavaScript populate it, let the service worker construct a stream where the
shell comes from a cache, but the body comes from the network. HTML rendered during the
initial nav request can then take full advantage of the browser's streaming HTML parser.

☐ Consider making your components connection-/device memory-aware.
Customize the application and the payload to cost- and performance-constrained users with
the Save-Data client hint request header. You could rewrite requests for high DPI images to
low DPI images, remove web fonts and parallax, turn off video autoplay, or even change how
you deliver markup. Use Network Information API to deliver variants of heavy components
based on connectivity, and Device Memory API to adjust resources based on device memory.

☐ Warm up the connection to speed up delivery.
Use resource hints to save time on dns-prefetch (DNS lookup in the background),
preconnect (start the connection handshake (DNS, TCP, TLS)), prefetch (request a resource),
preload (prefetch resources without executing them, among other things) and prerender
(fetches resources in advance but doesn’t execute JS or render any part of the page in advance).
When using preload, as must be defined or nothing loads; preloaded fonts without crossorigin
attribute will double fetch. With preload, there is a puzzle of priorities, so consider
injecting rel="preload" elements into the DOM just before the external blocking scripts.

☐ Use service workers for caching and network fallbacks.
If your website is running over HTTPS, cache static assets in a service worker cache and store
offline fallbacks (or even offline pages) and retrieve them from the user's machine, rather
than going to the network. Store the app shell in the service worker's cache along with a few
critical pages, such as offline page or homepage. But: make sure the proper CORS response
header exists for cross-origin resources, don’t cache opaque responses and opt-in cross-origin
image assets into CORS mode.

☐ Use service workers on the CDN/Edge (e.g. for A/B testing).
With CDNs implementing service workers on the server, consider service workers to tweak
performance on the edge as well. E.g. in A/B tests, when HTML needs to vary its content for
different users, use service workers on the CDNs to handle the logic. Or stream HTML
rewriting to speed up sites that use Google Fonts.

☐ Optimize rendering performance.
If needed, isolate expensive components with granular CSS containment. Make sure that
there is no lag when scrolling the page or when an element is animated, and that you’re
consistently hitting 60 frames per second. If that’s not possible, then making the frames per
second consistent is at least preferable to a mixed range of 60 to 15. Use CSS will-change to
inform the browser about which elements will change.

☐ Have you optimized rendering experience?
Don’t underestimate the role of perceived performance. While loading assets, try to always be
one step ahead of the customer, so the experience feels swift while there is quite a lot
happening in the background. To keep the customer engaged, use skeleton screens instead of
loading indicators and add transitions and animations.

☐ Prevent layout shifts (reflows) and repaints.
Reflows are caused by rescaled images and videos, web fonts, injected ads or late-discovered
scripts that populate components with actual content. Set width and height attributes on
images, so modern browsers allocate the box and reserve the space by default. Use an SVG

placeholder to reserve the display box in which the video and images will appear in. Use
hybrid lazy-loading to load an external lazy-loading script only if native lazy-loading isn’t
supported. Group web font repaints and match line-height and spacing with font-style-matcher.
Track the stability of the interface with Layout Instability API and Cumulative Layout Shift (CLS).

Networking and HTTP/2
☐ Is OCSP stapling enabled?
By enabling OCSP stapling on your server, you can speed up TLS handshakes. The OCSP
protocol does not require the browser to spend time downloading and then searching a list for
certificate information, hence reducing the time required for a handshake.

☐ Have you reduced the impact of SSL certificate revocation?
Extended Validation (EV) certificates are expensive and time-consuming as they require a
human to reviewing a certificate and ensuring its validity. Domain Validation (DV) certificates,
on the other hand, are often provided for free. EV certificates do not fully support OCSP
stapling, so always serve an OCSP stapled DV certificate and keep TLS certificates small.

☐ Have you adopted IPv6 yet?
Studies show that IPv6 makes websites 10 to 15% faster due to neighbor discovery (NDP) and
route optimization. Update the DNS for IPv6 to stay bulletproof for the future. Just make sure
that dual-stack support is provided across the network — it allows IPv6 and IPv4 to run
simultaneously alongside each other. After all, IPv6 is not backwards-compatible.

☐ Is TCP BBR in use?
BBR is a relatively new TCP delay-controlled TCP flow control algorithm. It responds to actual
congestion, rather than packet loss like TCP does, and as such, it’s significantly faster, with
higher throughput and lower latency. Enable BBR congestion control and set tcp_notsent_lowat
to 16KB for HTTP/2 prioritization to work reliably on Linux 4.9 kernels and later.

☐ Always prefer HTTP/2.
HTTP/2 is supported very well and offers a performance boost. It isn’t going anywhere, and in
most cases, you’re better off with it. Depending on how large your mobile user base is, you
might need to send different builds, and you could benefit from adapting a different build
process. (HTTP/2 is often slower on networks which have a noticeable packet loss rate.)

☐ Properly deploy HTTP/2.
You need to find a fine balance between packaging modules and loading many small modules

in parallel. Break down your entire interface into many small modules; then group, compress
and bundle them. Split at the package level, or by tracking which chunks of CSS/JS are/aren’t
used. Separate vendor and client code, and separate vendor dependencies that change rarely
and frequently. Sending around 6–10 packages seems like a decent compromise (and isn’t too
bad for legacy browsers). Experiment and measure to find the right balance. Do your best to
send as many assets as possible over a single HTTP/2 connection.

☐ Do your servers and CDNs support HTTP/2?
Different servers and CDNs support HTTP/2 differently. Use CDN Comparison to check your
options, or quickly look up which features you can expect to be supported. Enable BBR
congestion control, set tcp_notsent_lowat to 16KB for HTTP/2 prioritization.

☐ Is HPACK compression in use?
If you’re using HTTP/2, double-check that your servers implement HPACK compression for
HTTP response headers to reduce unnecessary overhead. Because HTTP/2 servers are
relatively new, they may not fully support the specification, with HPACK being an example.
H2spec is a great (if very technically detailed) tool to check that.

☐ Get ready for HTTP/3.
While in HTTP/2, multiple requests share a connection, in HTTP/3 requests also share a
connection but stream independently, so a dropped packet no longer impacts all requests, just
the one stream. With HTTP3’s QUIC, TCP and TLS are combined and completed in just a
single round trip, and from the second connection onward, we can already send and receive
app layer data in the first round trip (0-RTT). Packaging still matters, so instead of sending a
monolithic JS, send multiple JS-files in parallel. Expect an impact on loading times on mobile.

☐ Do your servers and CDNs support HTTP/3?
QUIC and HTTP/3 are better and more bulletproof: with faster handshakes, better encryption,
more reliable independent streams, more encrypted, and with 0-RTT if the client previously
had a connection with the server. However, it's quite CPU intensive (2-3x CPU usage for the
same bandwidth). Check if your servers or CDNs support HTTP over QUIC (also known
as HTTP/3), and if you can enable it.

☐ Make sure the security on your server is bulletproof.
Double-check that your security headers are set properly, eliminate known vulnerabilities,
and check your certificate. Make sure that all external plugins and tracking scripts are loaded
via HTTPS, that cross-site scripting isn’t possible and that both HTTP Strict Transport Security
headers and Content Security Policy headers are properly set.

Testing and Monitoring
☐ Monitor mixed-content warnings.
If you’ve recently migrated from HTTP to HTTPS, make sure to monitor both active and
passive mixed-content warnings with tools such as Report-URI.io. You can also use Mixed
Content Scan to scan your HTTPS-enabled website for mixed content.

☐ Have you optimized your auditing and debugging workflow?
Invest time to study debugging and auditing techniques in your debugger, WebPageTest,
Lighthouse and supercharge your text editor. E,g, you could drive WebPageTest from a Google
Spreadsheet and incorporate accessibility, performance and SEO scores into your Travis setup
with Lighthouse CI or straight into Webpack. Use a Perf Diagnostic CSS for quick check-ups.

☐ Have you tested in proxy browsers and legacy browsers?
Testing in Chrome and Firefox is not enough. Look into how your website works in proxy
browsers and legacy browsers (including UC Browser and Opera Mini). Measure average
Internet speed among your user base to avoid big surprises. Test with network throttling, and
emulate a high-DPI device. BrowserStack is fantastic, but test on real devices, too.

☐ Have you tested the performance of your 404 pages?
Every time a client requests an asset that doesn’t exist, they’ll receive a 404 response — and
often that response is huge. Make sure to examine and optimize the caching strategy for your
404 pages. Make sure to serve HTML to the browser only when it expects an HTML response,
and return a small error payload for all other responses.

☐ Have you tested the performance of your GDPR consent prompts?
Normally cookie consent prompts shouldn’t have an impact on CLS, but sometimes they do,
so consider using free and open source options Osano or cookie-consent-box. The consent is
likely to change the impact of scripts on the overall performance, so set up and study a few
different web performance profiles for different types of consent.

☐ Have you tested the impact on accessibility?
Large pages and DOM manipulations with JavaScript will cause delays in screen reader
announcements. Fast Time to Interactive means how much time passes by until the screen
reader can announce navigation on a given page and a screen reader user can actually hit
keyboard to interact.

☐ Is continuous monitoring set up?
A good performance metrics is a combination of passive and active monitoring tools. Having a
private instance of WebPagetest and using Lighthouse is always beneficial for quick tests, but

also set up continuous monitoring with RUM tools such as SpeedTracker, SpeedCurve and
others. Set your own user-timing marks to measure and monitor business-specific metrics.

Quick wins
This list is quite comprehensive, and completing all of the optimizations might take quite a while.
So, if you had just 1 hour to get significant improvements, what would you do? Let’s boil it all
down to 18 low-hanging fruits. Obviously, before you start and once you finish, measure results,
including Largest Contentful Paint and Time To Interactive on a 3G and cable connection.
1. Measure the real world experience and set appropriate goals. Aim to be at least 20% faster than
your fastest competitor. Stay within Largest Contentful Paint < 2.5s, a First Input Delay <
100ms, Time to Interactive < 5s on slow 3G, for repeat visits, TTI < 2s. Optimize at least for
First Contentful Paint and Time To Interactive.
2. Optimize images with Squoosh, mozjpeg, guetzli, pingo and SVGOMG, and serve AVIF/WebP with
an image CDN.
3. Prepare critical CSS for your main templates, and inline them in the <head> of each template.
For CSS/JS, operate within a critical file size budget of max. 170KB gzipped (0.7MB unzipped).
4. Trim, optimize, defer and lazy-load scripts. Invest in the config of your bundler to remove
redundancies and check lightweight alternatives.
5. Always self-host your static assets. Always prefer to self-host 3rd-party assets. Limit their
impact. Use facades, load widgets on interaction and beware of anti-flicker snippets.
6. Be selective when choosing a framework. For single-page-applications, identify critical pages
and serve them statically, or at least prerender them, and use progressive hydration on
component-level and import modules on interaction.
7. Client-side rendering alone isn't a good choice for performance. Prerender if your pages don’t
change much, and defer the booting of frameworks. Use streaming server-side rendering.
8. Serve legacy code only to legacy browsers with the module/nomodule pattern.
9. Experiment with regrouping your CSS rules and test in-body CSS.
10. Add resource hints to speed up delivery with dns-lookup, preconnect, prefetch, preload, prerender.
11. Subset web fonts and load them asynchronously, and utilize font-display in CSS for fast first
rendering.
12. Check that HTTP cache headers and security headers are set properly.
13. Enable Brotli compression on the server. (If that’s not possible, don’t forget to enable Gzip
compression.)
14. Enable TCP BBR congestion if your server is running on the Linux kernel version 4.9+.
15. Enable OCSP stapling and IPv6 if possible. Always serve an OCSP stapled DV certificate.
16. Enable HPACK compression for HTTP/2 and move to HTTP/3 if it's available.
17. Cache assets such as fonts, styles, JavaScript and images in a service worker cache.

18. Explore options to avoid rehydration, use progressive hydration and streaming server-side
rendering for your single-page application.
A huge thanks to Guy Podjarny, Yoav Weiss, Addy Osmani, Artem Denysov, Denys Mishunov, Ilya Pukhalski,
Jeremy Wagner, Colin Bendell, Mark Zeman, Patrick Meenan, Leonardo Losoviz, Andy Davies, Rachel Andrew,
Anselm Hannemann, Barry Pollard, Patrick Hamann, Gideon Pyzer, Andy Davies, Maria Prosvernina, Tim
Kadlec, Rey Bango, Matthias Ott, Peter Bowyer, Phil Walton, Mariana Peralta, Pepijn Senders, Mark
Nottingham, Jean Pierre Vincent, Philipp Tellis, Ryan Townsend, Ingrid Bergman, Mohamed Hussain S. H.,
Jacob Groß, Tim Swalling, Bob Visser, Kev Adamson, Adir Amsalem, Aleksey Kulikov and Rodney Rehm for
reviewing this article, as well as our fantastic community which has shared techniques and lessons learned
from its work in performance optimization for everybody to use. You are truly smashing!



2021 年前端性能清单
下面是您可能会遇到的前端性能问题的概述
需要考虑确保您的响应时间快速且顺畅。
____

做好准备：规划和指标
☐ 建立绩效文化。
只要没有企业的支持，业绩就不会长期维持。 学习
客户服务中常见的投诉，看看如何提高绩效
帮助缓解其中一些问题。 使用真实数据建立公司定制的案例研究
和业务指标。 在设计过程中计划加载顺序和权衡。

☐ 比最快的竞争对手快 20%。
在代表您的受众的设备上收集数据。 比模拟更喜欢真实设备。
选择 Moto G4/G5 Plus、中端三星设备（Galaxy A50、S8）、Nexus 5X、小米米 A3 或小米红米 Note 7 等中档设备以及慢速设备，例如
阿尔卡特 1X 或 Cubot X19。 或者，通过在桌面上进行测试来模拟桌面上的移动体验
具有节流 CPU（5×
减速）。 然后切换到常规 3G、慢速 4G（例如 170 毫秒 RTT、9 Mbps 下降、9 Mbps
向上）和 Wi-Fi。 收集数据，设置电子表格，减少 20%，并设定你的目标
（绩效预算）。

☐ 选择正确的指标。
并非每个指标都同样重要。 研究最重要的指标：通常是
与您可以多快开始渲染最重要的像素以及您可以多快地提供有关
输入响应。 优先考虑客户认为的页面加载。 时间到
交互式、首次输入延迟、英雄渲染时间、最大内容绘制、总阻塞
时间和累积布局偏移通常很重要。 不是：第一次有意义的绘画。

☐ 设置“清洁”和“客户”配置文件以进行测试。
关闭防病毒和后台 CPU 任务，删除后台带宽传输和
使用没有浏览器扩展的干净用户配置文件进行测试，以避免出现偏差的结果。 学习
您的客户使用哪些扩展，并使用专门的“客户”配置文件进行测试。
由维塔利弗里德曼策划。 永久网址：www.smashed.by/perf-checklist。 2021 年 1 月 11 日。

☐ 与您的同事分享清单。
确保团队中的每个成员都熟悉清单。 每个决定都有
性能影响，并且您的项目将从分发中受益匪浅
整个团队的所有权。 根据性能预算映射设计决策。

设定切合实际的目标
☐ 100 毫秒响应时间，每秒 60 帧。
每一帧动画应该在 16 毫秒内完成——最好是 10
毫秒，从而达到每秒 60 帧（1 秒 ÷ 60 = 16.6 毫秒）。 是
乐观并明智地利用空闲时间。 对于动画这样的高压点，最好做
没有其他你可以的地方和你不能的绝对最低限度。 估计输入
延迟应低于 50 毫秒。 明智地使用空闲时间，采用空闲直到紧急的方法。

☐ LCP < 2.5s，FID < 100ms，CLS < 0.1，3G 交互时间 < 5s。
考虑到基线是 200 美元的 Android 手机，速度较慢，RTT 为 400 毫秒
和 400kbps 的传输速度，目标是交互时间小于 5 秒，重复访问时间小于 2-3 秒。
目标是最大的 Contentful Paint < 2.5s 并最小化总阻塞时间和累积布局
转移。 努力使这些值尽可能低。

☐ 关键文件大小预算 < 170KB
HTML 的前 14–16KB 是最关键的有效负载块——也是唯一的部分
可以在第一次往返中交付的预算。 为实现上述目标，操作
在最大的关键文件大小预算内。 170KB gzipped（0.7-0.8MB 解压缩。确保
您的预算会根据网络条件和硬件限制而变化。

定义环境
☐ 选择并设置您的构建工具。
不要太在意所谓的酷。 只要你能快速得到结果
你在维护你的构建过程中没有问题，你做得很好。 唯一的例外
可能是 Webpack 或 Parcel，它们提供有用的优化技术，例如代码拆分。 如果尚未使用，请确保详细了解代码拆分和 tree-shaking。

☐ 默认使用渐进增强。
首先设计和构建核心体验，然后通过高级增强体验
功能强大的浏览器的功能，创造弹性体验。 如果您的网站在

在次优网络上的不良浏览器中屏幕不良的慢速机器，那么它只会
在性能良好的网络上使用良好的浏览器在快速的机器上运行得更快。

☐ 选择一个强大的性能基准。
JavaScript 的体验成本最高。 170KB 的预算已经包含
关键路径 HTML/CSS/JavaScript、路由器、状态管理、实用程序、框架和
应用程序逻辑，彻底检查网络传输成本、解析/编译时间和
运行
我们选择的框架的成本。

☐ 评估每个框架和每个依赖项。
不是每个项目都需要框架，也不是SPA的每个页面都需要加载框架。 是
深思熟虑你的选择。 通过探索功能、可访问性、稳定性来评估第三方 JS，
性能、包生态系统、学习曲线、文档、工具、跟踪记录、团队、
兼容性和安全性。 Next.js (React)、Gatsby (React)、Vuepress (Vue) 和 Preact
CLI 提供合理的默认值，以便在普通移动硬件上快速加载。

☐ 明智地选择你的战斗：React、Vue、Angular、Ember 和 Co。
确保您选择的框架提供服务器端呈现或预呈现。
在决定之前测量移动设备上服务器和客户端呈现模式的启动时间。
了解您将依赖的框架的具体细节。 查看 PRPL 模式
和应用程序外壳架构。 值得注意的选项是 Preact、Inferno、Vue、Svelte、Alpine、Polymer。

☐ 优化 API 的性能。
如果许多资源需要来自 API 的数据，API 可能会成为性能瓶颈。
考虑使用 GraphQL，一种查询语言和服务器端运行时来执行查询
使用您为数据定义的类型系统。 与 REST 不同，GraphQL 可以检索一个文件中的所有数据
单个请求，不会像 REST 通常发生的那样获取过多或不足的数据。

☐ 您会使用 AMP 还是 Instant Articles？
没有它们您也可以实现良好的性能，但 AMP 可能会提供可靠的性能
框架，带有免费的 CDN，而 Instant Articles 将提高您的知名度和性能
在Facebook上。 您也可以构建渐进式网络 AMP。

☐ 明智地选择您的 CDN。
根据您拥有的动态数据量，您可以“外包”某些部分
内容到静态站点生成器，将其推送到 CDN 并从中提供静态版本，
从而避免数据库请求（JAMStack）。 仔细检查您的 CDN 是否执行内容
压缩和转换，（例如在格式、压缩和转换方面的图像优化
在边缘调整大小），支持服务器工作人员和边缘端包括你。

资产优化
☐ 使用 Brotli 进行纯文本压缩。
Brotli 是一种新的无损数据格式，现在所有现代浏览器都支持它。 更有效
比 Gzip 和 Deflate 压缩速度慢，但解压速度快。 预压缩静态
在最高级别使用 Brotli+Gzip 的资产，使用 Brotli 即时压缩（动态）HTML
在 1-4 级。 还要检查 CDN 上的 Brotli 支持。 确保服务器处理内容
正确协商 Brotli 或 gzip。

☐ 使用响应式图像、AVIF 和 WebP。
尽可能使用带有 srcset、sizes、<picture> 和 image-set 的响应式图像。 AVIF > WebP。
使用 <picture> 和 JPEG/PNG 后备，或使用内容提供 AVIF 和 WebP 格式
协商（使用 Accept 标头）。 注意：使用 WebP，你会减少负载，但使用 JPEG
你会提高感知性能，所以用户可能会更快地看到一个良好的实际图像
ol' JPEG 尽管 WebP 图像可能通过网络变得更快。

☐ 图像是否适当优化？
将 mozJPEG 用于 JPEG 压缩，将 SVGO 用于 SVG 压缩，将 Pingo 用于 PNG——或 Squoosh
对于所有这些（包括 AVIF）。 要检查响应式标记的效率，您可以
使用成像堆。 对于关键图像，使用渐进式 JPEG 并模糊掉不必要的部分
（通过应用高斯模糊滤镜）并移除对比度（您可以使用 CSS 滤镜重新应用它）。
确保为所有图像定义宽度和高度，将自动图像压缩添加到
您的拉取请求并研究延迟加载不太重要的图像。

☐ 视频是否经过适当优化？
代替动画 GIF，使用动画 WebP（GIF 作为后备）或循环播放
内联 HTML5 视频。 确保您的 MP4 文件经过多通道编码处理，
使用 frei0r iirblur 效果模糊（如果适用）并将 moov 原子元数据移动到头部
的文件，而您的服务器接受字节服务。 尽可能以 AV1 格式提供视频
格式，但也提供后备。 调整视频大小并使用自适应媒体服务提供
您的客户实际上可以在其设备上无延迟地播放的内容。

☐ 网络字体是否优化？
子集字体。 首选 WOFF2 并使用 WOFF 作为后备。 在回退中显示内容
立即加载字体，异步加载字体，然后按顺序切换字体。 最终解决方案：双阶段渲染，首先使用一个小的超子集，然后再异步加载其余部分。
预加载每个系列的 1-2 种字体。 避免字体声明的 local() 值，但考虑
本地安装的操作系统字体。 不要忘记包含字体显示：可选并使用字体加载事件
用于组重绘。 使用 Web Font Reflow Count 和 Time To Real Italics 指标。

构建优化
☐ 正确设置您的优先顺序。
对您的所有资产（JavaScript、图像、字体、第三方脚本、
页面上的“昂贵”模块
e)，并将它们分组。 定义基本核心
体验（旧版浏览器完全可访问的核心内容）、增强体验（一个
功能强大的浏览器丰富的完整体验）和附加功能（并非绝对的资产
必需的，并且可以延迟加载）。

☐ 在生产中使用原生 JavaScript 模块。
将核心体验发送到旧版浏览器，将增强体验发送到现代浏览器。
使用 ES2017+ <script type="module"> 加载 JavaScript：现代浏览器将解释
将脚本作为 JavaScript 模块并按预期运行，而旧版浏览器无法识别
它，因此忽略它。

☐ 执行 JavaScript 是昂贵的，所以驯服它。
使用 SPA，您可能需要一些时间来初始化应用程序，然后才能呈现页面。
寻找模块和技术来加快初始渲染时间，例如 有进取心的
水合作用和导入交互（低端移动设备上的时间高出 2-5 倍）。

☐ 使用 tree-shaking、scope hoisting 和 code-splitting 来减少负载。
Tree-shaking 是一种清理构建过程的方法，它只包含实际需要的代码
用于生产。 代码拆分将您的代码库拆分为加载到的“块”
要求。 范围提升检测导入链接可以展平并转换为的位置
一个不影响代码的内联函数（例如通过 Webpack）。 使用粒度
分块并将一些客户端渲染卸载到服务器。 定义分割点
跟踪哪些 CSS/JS 块被使用，哪些没有。 考虑在
包级也是如此。

☐ 你能将 JavaScript 卸载到 Web Worker 或 WebAssembly 中吗？
随着代码库的发展，UI 性能瓶颈将开始显现。 它发生了
因为 DOM 操作在主线程上与您的 JS 一起运行。 考虑搬家
这些昂贵的操作到在不同线程上运行的后台进程
网络工作者。 典型用例：预取数据和 PWA。 考虑卸载
计算繁重的任务交给 WebAssembly，它最适合计算
密集型网络应用程序，例如游戏。

☐ 仅将遗留代码提供给遗留浏览器（差异化服务）。
使用 babel-preset-env 只转译现代浏览器不支持的 ES2017+ 特性
你在瞄准。 然后设置两个构建，一个用于现代浏览器，一个用于旧版浏览器。 为了

lodash，使用 babel-plugin-lodash 它将只加载您在源代码中使用的模块。
将通用的 lodash requires 转换为精选的 lodash 以避免代码重复。 使用
header <link rel="modulepreload"> 启动模块脚本的早期（和高优先级）加载。

☐ 通过增量解耦识别和重写遗留代码。
重新访问您的依赖项并评估重构或重写需要多少时间
最近引起麻烦的遗留代码。 首先，设置指标来跟踪
遗留代码调用保持不变或下降，而不是上升。 公开劝阻团队
使用该库并确保您的 CI 提醒开发人员是否在拉取请求中使用它。

☐ 识别并删除未使用的 CSS/JavaScript。
Chrome 中的 CSS 和 JavaScript 代码覆盖率可让您了解哪些代码已被
已执行/应用，哪些尚未执行。 检测到未使用的代码后，找到那些模块
并使用 import() 进行延迟加载。 然后重复覆盖范围配置文件并验证它现在
在初始加载时发送更少的代码。 使用 Puppeteer 以编程方式收集代码覆盖率。

☐ 减少 JavaScript 依赖项的大小。
当您只需要一小部分时，您很有可能会发布完整的 JavaScript 库。
为避免开销，请考虑使用 webpack-libs-optimizations 删除未使用的方法
和 polyfills 在构建过程中。 将捆绑审核添加到您的常规工作流程中。
Bundlephobia 有助于找到将 npm 包添加到包中的成本，大小限制扩展
基本的包大小检查以及 JavaScript 执行时间的详细信息。 使用 Skypack 发现
专注于质量和性能的社区策划包。

☐ 您是否对 JavaScript 块使用预测预取？
使用启发式方法来决定何时预加载 JavaScript 块。 Guess.js 是一组使用
用于确定用户接下来最有可能访问哪个页面的 Google Analytics 数据。 还，
考虑 Quicklink、Instant.page 和 DNStradamus。 注意：您可能会提示浏览器
消耗不需要的数据并预取不需要的页面，所以最好是相当
保守的预取请求数量。

☐ 优化您的目标 JavaScript 引擎。
对整体脚本使用脚本流，这样它们就可以在单独的服务器上进行解析
下载开始后的后台线程。 通过拆分也可以挂钩到 V8 的代码缓存中
从使用它们的代码中取出库，或相反。 考虑 JIT 优化
Firefox 的 Baseline Interpeter 策略也是如此。

☐ 找到一种结合客户端渲染和服务器端渲染的方法渲染。
通常目标是在客户端和服务器端渲染之间找到最佳平衡。
如果您的页面变化不大，请考虑预渲染，并推迟框架的启动

如果可以的话。 使用服务器端渲染以块的形式流式传输 HTML，并实现渐进式
通过客户端渲染对单个组件进行水合作用——并根据可见性进行水合作用，
交互或在空闲时间获得两全其美。 （流式服务器端渲染
随着渐进水合作用）。

☐ 考虑微优化和渐进式引导。
使用服务器端渲染来获得快速的第一次有意义的绘画，但也包括一些
最小化 JS 以保持交互时间接近第一次有意义的绘制。 然后，要么在
根据需要或在时间允许的情况下，启动应用程序的非必要部分。 总是中断执行
功能分成单独的异步任务。 尽可能使用 requestIdleCallback。

☐ 始终自行托管第三方资产。
使用公共 CDN 不会自动带来更好的性能。 即使两个站点指向
到完全相同的第三方资源 URL，每个域下载一次代码，并且
缓存被“沙盒化”到该域。 第一方资产更有可能留在缓存中
比第三方资产。 自托管更可靠、更安全，性能也更好。

☐ 限制第三方脚本的影响。
一个第三方脚本经常会调用一长串脚本。 考虑使用
service workers 通过在超时的情况下竞速资源下载。 建立内容安全
限制第三方脚本影响的策略 (CSP)，例如 禁止下载音频
或视频。 通过 iframe 嵌入脚本，因此脚本无法访问 DOM。 沙箱他们也是。
要对脚本进行压力测试，请检查性能配置文件页面 (DevTools) 中的自下而上的摘要。
仅在应用程序初始化后加载第三方脚本。 注意防闪烁片段。

☐ 正确设置 HTTP 缓存标头。
仔细检查是否设置了过期、缓存控制、最大年龄和其他 HTTP 缓存标头
适当地。 一般来说，资源应该可以缓存很短的时间（如果它们是
可能会改变）或无限期地（如果它们是静态的）。 使用 cache-control: immutable 来避免
重新验证。 检查您是否发送了不必要的标头（例如 x-powered-by、pragma、xua-compatible、expires）。 通过 stale-while-revalidate 使用零 RTT 重复查看。

交付优化
☐ 异步加载 JavaScript。
作为开发人员，我们必须明确告诉浏览器不要等待并开始渲染页面
使用 HTML 中的 defer 和 async 属性。 总是喜欢延迟而不是异步。 使用延迟，浏览器
在解析 HTML 并且执行所有先前的同步脚本之前不执行脚本。 不
两者都用。 除非你需要在开始渲染之前执行JS，否则最好使用defer。

☐ 使用 IntersectionObserver 延迟加载昂贵的组件。
延迟加载所有昂贵的组件，例如繁重的 JavaScript、视频、iframe、小部件和
潜在的图像。 最有效的方法是使用本机延迟加载
（加载和重要性属性）或使用 Intersection Observer——后者可以是
也用于高性能滚动、视差和广告跟踪。

☐ 延迟昂贵图像的渲染和解码。
使用 content-visibility: auto，我们可以提示浏览器跳过孩子的布局
容器在视口之外。 只需确保将 contain-intrinsic-size 与
占位符大小合适以避免 CLS。 此外，提示浏览器解码图像关闭
带有 <img decoding=“async”> 的主线程，以减少操作所需的 CPU 时间。

☐ 快速推送关键 CSS。
收集开始呈现页面第一个可见部分所需的所有 CSS（“关键
CSS”或“首屏”CSS），并将其内联添加到页面的 <head> 中（保持在 14 KB 以下）。
考虑条件内联方法。 将关键 CSS 放在根目录下的单独文件中
domain 有好处，有时由于缓存而比内联更多。

☐ 尝试重新组合您的 CSS 规则。
考虑将主 CSS 文件拆分成单独的媒体查询。 避免放置 <link
rel="stylesheet" /> 在异步片段之前。 如果脚本不依赖于样式表，请考虑放置
阻塞样式之上的阻塞脚本。 如果他们这样做，将 JavaScript 分成两部分并加载它
你的CSS的一面。 使用 Service Worker 缓存内联 CSS 并试验体内 CSS。
动态样式可能很昂贵：检查您的 CSS-in-JS 库是否优化了执行
当你的 CSS 不依赖于主题/道具时，不要过度组合样式组件。我在哪里
外壳来自缓存，但主体来自网络。 期间呈现的 HTML
然后初始导航请求可以充分利用浏览器的流式 HTML 解析器。

☐ 考虑让您的组件连接/设备内存感知。
为成本和性能受限的用户定制应用程序和负载
Save-Data 客户端提示请求标头。 您可以将对高 DPI 图像的请求重写为
低 DPI 图像、删除网络字体和视差、关闭视频自动播放，甚至更改播放方式
你提供标记。 使用 Network Information API 传递重型组件的变体
基于连接和设备内存 API 来调整基于设备内存的资源。

☐ 预热连接以加快交付速度。
使用资源提示来节省 dns-prefetch 的时间（在后台进行 DNS 查找），
预连接（启动连接握手（DNS、TCP、TLS））、预取（请求资源）、
预加载（预取资源而不执行它们等）和预渲染
（提前获取资源但不执行JS或提前渲染页面的任何部分）。
使用预加载时，必须定义或不加载； 没有跨源的预加载字体
属性将双重获取。 对于预加载，有一个优先级的难题，所以考虑
在外部阻塞脚本之前将 rel="preload" 元素注入 DOM。

☐ 使用服务工作者进行缓存和网络回退。
如果您的网站通过 HTTPS 运行，请将静态资产缓存在 Service Worker 缓存中并存储
离线后备（甚至离线页面）并从用户的机器上检索它们，而不是
比去网络。 将 App Shell 连同一些存储在 Service Worker 的缓存中
关键页面，例如离线页面或主页。 但是：确保正确的 CORS 响应
跨源资源存在标头，不要缓存不透明的响应和选择加入跨源
将图像资产转换为 CORS 模式。

☐ 在 CDN/Edge 上使用服务工作者（例如用于 A/B 测试）。
随着 CDN 在服务器上实现服务工作者，考虑服务工作者进行调整
边缘的性能也是如此。 例如。 在 A/B 测试中，当 HTML 需要改变其内容时
不同的用户，使用 CDN 上的服务工作者来处理逻辑。 或者流式传输 HTML
重写以加速使用谷歌字体的网站。

☐ 优化渲染性能。
如果需要，使用精细的 CSS 容器隔离昂贵的组件。 确保
滚动页面或动画元素时没有延迟，而且您
始终达到每秒 60 帧。 如果那不可能，那么制作帧
second consistent 至少优于 60 到 15 的混合范围。使用 CSS will-change 来
通知浏览器哪些元素将发生变化。

☐ 是否优化了渲染体验？
不要低估感知绩效的作用。 在加载资产时，尽量始终
领先客户一步，所以体验很快，同时有很多
发生在后台。 为了保持客户的参与度，请使用骨架屏幕而不是
加载指示器并添加过渡和动画。

☐ 防止布局偏移（回流）和重绘。
回流是由重新缩放的图像和视频、网络字体、注入的广告或较晚发现的
用实际内容填充组件的脚本。 设置宽度和高度属性
图像，因此现代浏览器默认分配框并保留空间。 使用 SVG

占位符以保留显示视频和图像的显示框。使用
混合延迟加载仅在本机延迟加载不是时才加载外部延迟加载脚本
支持的。 分组网络字体重绘并使用字体样式匹配器匹配行高和间距。
使用 Layout Instability API 和 Cumulative Layout Shift (CLS) 跟踪界面的稳定性。

网络和 HTTP/2
☐ 是否启用了 OCSP 装订？
通过在您的服务器上启用 OCSP 装订，您可以加速 TLS 握手。 OCSP
协议不需要浏览器花时间下载然后搜索列表
证书信息，从而减少握手所需的时间。

☐ 您是否减少了 SSL 证书吊销的影响？
扩展验证 (EV) 证书既昂贵又耗时，因为它们需要
审查证书并确保其有效性的人。 域验证 (DV) 证书，
另一方面，通常是免费提供的。 EV 证书不完全支持 OCSP
装订，因此始终提供 OCSP 装订 DV 证书并保持 TLS 证书较小。

☐ 您采用 IPv6 了吗？
研究表明，由于邻居发现 (NDP) 和
路线优化。 更新 IPv6 的 DNS，以防万一。 只要确定
跨网络提供双栈支持——它允许 IPv6 和 IPv4 运行
同时并排。 毕竟，IPv6 不向后兼容。

☐ TCP BBR 是否在使用中？
BBR是一个相对较新的

☐ 流式响应。
Streams 提供了一个用于读取或写入异步数据块的接口，只有一个
其中的子集可能在任何给定时间在内存中可用。 而不是提供一个空的
UI shell 并让 JavaScript 填充它，让 service worker 构造一个 str
TCP delay-controlled TCP流量控制算法。 它响应实际
拥塞，而不是像 TCP 那样丢失数据包，因此，它的速度要快得多，
更高的吞吐量和更低的延迟。 启用 BBR 拥塞控制并设置 tcp_notsent_lowat
到 16KB 的 HTTP/2 优先级，以便在 Linux 4.9 内核及更高版本上可靠地工作。

☐ 总是喜欢 HTTP/2。
HTTP/2 得到了很好的支持，并提供了性能提升。 它不会去任何地方，而且在
在大多数情况下，您最好不要这样做。 根据您的移动用户群有多大，您
可能需要发送不同的构建，您可以从调整不同的构建中受益
过程。 （HTTP/2 在具有明显丢包率的网络上通常较慢。）

☐ 正确部署 HTTP/2。
你需要在打包模块和加载很多小模块之间找到一个很好的平衡点

在平行下。 将你的整个界面分解成许多小模块； 然后分组，压缩
并将它们捆绑在一起。 在包级别拆分，或者通过跟踪哪些 CSS/JS 块是/不是
用过的。 分离供应商和客户端代码，分离很少更改的供应商依赖项
并且经常。 发送大约 6-10 个包裹似乎是一个不错的妥协（而且也不是
对旧版浏览器不利）。 进行实验和测量以找到合适的平衡点。 尽力而为
通过单个 HTTP/2 连接发送尽可能多的资产。

☐ 您的服务器和 CDN 是否支持 HTTP/2？
不同的服务器和 CDN 支持 HTTP/2 的方式不同。 使用 CDN 比较来检查您的
选项，或快速查找您希望获得支持的功能。 启用 BBR
拥塞控制，将 tcp_notsent_lowat 设置为 16KB 用于 HTTP/2 优先级。

☐ 是否使用了 HPACK 压缩？
如果您使用的是 HTTP/2，请仔细检查您的服务器是否实现了 HPACK 压缩
HTTP 响应标头以减少不必要的开销。 因为 HTTP/2 服务器是
相对较新，它们可能不完全支持该规范，HPACK 就是一个例子。
H2spec 是一个很棒的（如果技术上非常详细的话）工具来检查它。

☐ 为 HTTP/3 做好准备。
在 HTTP/2 中，多个请求共享一个连接，而在 HTTP/3 中，请求也共享一个
连接但独立流，因此丢弃的数据包不再影响所有请求，只是
一个流。 通过 HTTP3 的 QUIC，TCP 和 TLS 结合在一起，只需一个
单次往返，从第二个连接开始，我们已经可以发送和接收
第一次往返（0-RTT）中的应用层数据。 包装仍然很重要，所以与其发送
单体 JS，并行发送多个 JS 文件。 预计会影响移动设备的加载时间。

☐ 您的服务器和 CDN 是否支持 HTTP/3？
QUIC 和 HTTP/3 更好更可靠：握手速度更快，加密更好，
更可靠的独立流，更加密，如果客户端之前使用 0-RTT
与服务器建立了连接。 但是，它非常占用 CPU（2-3 倍的 CPU 使用率）
带宽相同）。 检查您的服务器或 CDN 是否支持 HTTP over QUIC（也称为
作为 HTTP/3)，以及是否可以启用它。

☐ 确保您的服务器安全无懈可击。
仔细检查您的安全标头是否设置正确，消除已知漏洞，
并检查您的证书。 确保加载所有外部插件和跟踪脚本
通过 HTTPS，跨站点脚本是不可能的，而且 HTTP 严格传输安全
标头和内容安全策略标头已正确设置。

测试和监控
☐ 监控混合内容警告。
如果您最近从 HTTP 迁移到 HTTPS，请确保同时监控活动和
使用 Report-URI.io 等工具的被动混合内容警告。 您还可以使用混合
内容扫描以扫描启用 HTTPS 的网站以查找混合内容。

☐ 您是否优化了审核和调试工作流程？
花时间研究调试器 WebPageTest 中的调试和审计技术，
灯塔并增强您的文本编辑器。 例如，您可以从 Google 驱动 WebPageTest
电子表格并将可访问性、性能和 SEO 分数合并到您的 Travis 设置中
使用 Lighthouse CI 或直接进入 Webpack。 使用 Perf Diagnostic CSS 进行快速检查。

☐ 您是否在代理浏览器和旧版浏览器中进行过测试？
在 Chrome 和 Firefox 中测试是不够的。 查看您的网站如何在代理中运行
浏览器和旧版浏览器（包括 UC 浏览器和 Opera Mini）。 测量平均值
您的用户群中的互联网速度，以避免大的意外。 测试网络节流，以及
模拟高 DPI 设备。 BrowserStack 很棒，但也要在真实设备上进行测试。

☐ 您是否测试过 404 页面的性能？
每次客户请求不存在的资产时，他们都会收到 404 响应——并且
通常这种反应是巨大的。 确保检查并优化您的缓存策略
404 页。 确保仅在浏览器需要 HTML 响应时才向浏览器提供 HTML，
并为所有其他响应返回一个小错误负载。

☐ 你测试过性能吗您的 GDPR 同意提示？
通常 cookie 同意提示不应该对 CLS 产生影响，但有时它们会产生影响，
所以考虑使用免费和开源选项 Osano 或 cookie-consent-box。 同意是
可能会改变脚本对整体性能的影响，所以设置和研究一些
针对不同类型的同意使用不同的网络性能配置文件。

☐ 您是否测试了对可访问性的影响？
使用 JavaScript 进行大页面和 DOM 操作会导致屏幕阅读器出现延迟
公告。 Fast Time to Interactive 意味着屏幕显示之前经过了多少时间
阅读器可以在给定页面上宣布导航，屏幕阅读器用户可以实际点击
键盘进行交互。

☐ 是否设置了持续监控？
一个好的性能指标是被动和主动监控工具的组合。 有一个
WebPagetest 的私有实例和使用 Lighthouse 总是有利于快速测试，但是

还可以使用 RUM 工具（例如 SpeedTracker、SpeedCurve 和
其他的。 设置您自己的用户时间标记来衡量和监控特定于业务的指标。

速赢
此列表非常全面，完成所有优化可能需要相当长的时间。
那么，如果您只有 1 小时的时间来获得重大改进，您会怎么做？ 让我们把它全部煮沸
低至 18 个唾手可得的果实。 显然，在开始之前和完成后，衡量结果，
包括 Largest Contentful Paint 和 Time To Interactive 在 3G 和电缆连接上。
1.衡量真实世界的经验并设定适当的目标。 目标是至少快 20%
你最快的竞争对手。 保持最大内容绘制 < 2.5 秒，第一次输入延迟 <
100 毫秒，在慢速 3G 上交互时间 < 5 秒，对于重复访问，TTI < 2 秒。 至少优化
第一次内容丰富的绘画和互动时间。
2. 使用 Squoosh、mozjpeg、guetzli、pingo 和 SVGOMG 优化图像，并使用 AVIF/WebP 服务
图片CDN。
3. 为你的主要模板准备关键的 CSS，并将它们内联到每个模板的 <head> 中。
对于 CSS/JS，在最大的关键文件大小预算内运行。 gzip 后 170KB（解压后 0.7MB）。
4. 修剪、优化、延迟和延迟加载脚本。 投资您的捆绑器的配置以删除
冗余并检查轻量级替代方案。
5.始终自行托管您的静态资产。 总是喜欢自托管 3rd 方资产。 限制他们的
影响。 使用外观，在交互时加载小部件并注意防闪烁片段。
6. 选择框架时要有选择性。 对于单页应用程序，确定关键页面
并静态地提供它们，或者至少预渲染它们，并使用渐进式水合作用
组件级和导入模块交互。
7. 单独的客户端渲染并不是提高性能的好选择。 如果您的页面没有预呈现
变化很大，并推迟框架的启动。 使用流式服务器端渲染。
8. 仅使用模块/无模块模式将遗留代码提供给遗留浏览器。
9. 尝试重新组合您的 CSS 规则并测试 in-body CSS。
10. 添加资源提示以通过 dns-lookup、preconnect、prefetch、preload、prerender 加速交付。
11. 子集网络字体并异步加载它们，并利用 CSS 中的 font-display 实现快速优先
渲染。
12. 检查 HTTP 缓存标头和安全标头是否设置正确。
13. 在服务器上启用 Brotli 压缩。 （如果不可能，请不要忘记启用 Gzip
压缩。）
14. 如果您的服务器在 Linux 内核版本 4.9+ 上运行，则启用 TCP BBR 拥塞。
15. 如果可能，启用 OCSP 装订和 IPv6。 始终提供 OCSP 装订 DV 证书。
16. 为 HTTP/2 启用 HPACK 压缩，如果可用则转移到 HTTP/3。
17. 在 Service Worker 缓存中缓存字体、样式、JavaScript 和图像等资产。

18.探索避免再水化的选项，使用渐进式水化和流式服务器端
为您的单页应用程序呈现。
非常感谢 Guy Podjarny、Yoav Weiss、Addy Osmani、Artem Denysov、Denys Mishunov、Ilya Pukhalski，
杰瑞米·瓦格纳、科林·本德尔、马克·泽曼、帕特里克·米南、莱昂纳多·洛索维兹、安迪·戴维斯、雷切尔·安德鲁、
安塞姆·汉内曼、巴里·波拉德、帕特里克·哈曼、吉迪恩·派泽、安迪·戴维斯、玛丽亚·普罗维尼娜、蒂姆
卡德莱克、雷伊班戈、马蒂亚斯奥特、彼得鲍耶、菲尔沃尔顿、马里亚纳佩拉尔塔、佩宾森德斯、马克
诺丁汉，让·皮埃尔·文森特，菲利普·泰利斯，瑞恩·汤森德，英格丽·褒曼，穆罕默德·侯赛因 S.H.，
Jacob Groß、Tim Swalling、Bob Visser、Kev Adamson、Adir Amsalem、Aleksey Kulikov 和 Rodney Rehm
回顾这篇文章，以及我们分享技术和经验教训的奇妙社区
来自其在性能优化方面的工作，供大家使用。 你真的很厉害！