单线程的 JavaScript 管理任务

同步任务与异步任务
同步任务：在主线程上排队的任务，当前一个任务完整的执行了之后，后面的任务在执行
异步任务：不会阻塞阻塞主线程，当其任务执行完成之后，在根据一定的规则其执行相关的回调

同步任务与函数调用栈
js 解释器会以栈的方式管理执行上下文，以及函数之间的调用关系，

JavaScript 中代码执行的过程
1 首先进入全局环境，全局环境执行上下文被创建并被添加到栈中
2 每调用一个函数，该函数的执行上下文都会被添加到调用栈中，并开始执行
3 如果正在调用栈中执行的a函数调用了b函数，那么b函数也会被放进调用栈，并开始执行
4 一旦b函数被调用，会立即执行
5 当前函数执行完毕之后，，js解释器会将其清除出调用栈，继续执行当前执行环境下的剩余代码

因为栈的容量是有限制的，当没有合理调用函数的时候，可能会导致爆栈异常 

异步任务与回调队列
异步任务包括一些需要等待响应的任务，包括用户交互 http请求，定时器等

例如 I/O 类型的任务会有较长的等待时间，这种无法立即得到结果的事件，可以使用异步的方式

异步任务需要回调函数，""""当异步任务有了回调结果了之后，该任务则会被添加到回调队列中""""，主线程则会在适当的时候从回调队列中取出对应的回调函数并执行

回调队列是啥？
回调队列中都是已经有了运行结果的异步任务，每一个异步任务都关联着一个回调函数。

回调队列， 先进先出，js在执行时：
1.运行时,会从最先进入队列的任务开始，处理队列中的任务，
2。被处理任务会被移出队列，并将任务的运行结果作为输入参数，并调用与其关联的回调函数，此时会 产生一个调用栈
3。函数会一直处理到调用栈为空，然后Event loop 将会处理队列中的下一个任务


单线程的js是如何管理任务的
js中有一个基于事件循环的并发模型，称为事件循环 event loop
Event loop 主要是用来管理单线程的js中同步任务和异步任务的执行问题

根据js中的运行环境的不同，有浏览器的eventloop 和node的event loop

浏览器的event loop 

在浏览器里，每当一个被监听的事件发生时，事件监听器绑定的相关任务就会被添加进回调队列，通过事件产生的任务是异步任务，常见的事件任务包括：
用户交互事件产生的事件任务，比如输入操作，
计时器产生的事件任务 比如，settimeout
异步请求产生的事件任务

主线程运行的时候，会产生堆和栈，堆为内存，栈为调用栈，event loop 负责执行代码 收集和处理事件，以及执行队列中的子任务，具体如下：
1 js 会一个主线程和调用栈，所有任务都会放到调用栈中等待主线程执行，
2 同步任务都会放到调用栈中，按照顺序等待主任务执行，
主线程之外存在一个回调队列，回调队列中的异步任务最终会在主线程中以调用栈的方式运行。
3 同步任务都会在主线程上执行，栈中的代码会在执行的时候调用浏览器的api，此时会产生一些异步任务，
4 异步任务有了结果之后，将异步任务以及关联的回调函数放进队列，
5 调用栈中任务执行完毕之后，栈处于空闲状态，会从回调队列中获取任务进行处理

event loop 弊端：
settimeout 和setinterval 时间的不准确性
要优化这个问题，可以使用系统时钟来补偿计时器的不准确性，从而提升精确度。举个例子，如果你的计时器会在回调时触发二次计时，可以在每次回调任务结束的时候，根据最初的系统时间和该任务的执行时间进行差值比较，来修正后续的计时器时间。

Node.js 中的 Event Loop
但是event loop 的设计nodejs可以通过将操作转移到系统内核中，而不是执行I/O操作

Node.js 中的事件循环执行过程为：
1 当nodejs启动时初始化事件循环，处理提供的输入脚本
2 提供的输入脚本可以进行异步api调用，然后开始处理事件循环
3 在事件循环的每次运行之间，nodejs会检查它是否正在等待任何异步IO或者计时器，如果没有 则将起干净的关闭

nodejs中事件循环分成不同的阶段

timers 此阶段有setimeout 和setinterval 执行
pending callbacks 执行推迟到下一个迭代的IO回调
idle/prepare 仅在nodejs内部进行调用
poll 检索新的IO事件，执行与IO相关的回调，节点将在此处阻塞
check setImmediate() 在这里调回调
close callbacks 一些关闭回调，例如socket.on()

事件循环中的异步回调队列有两种：宏任务（MacroTask）和微任务（MicroTask）队列。
宏任务：全部的script代码，settimeout setinterval setimmediate（nodejs）
requestAnimationFrame(callback): 告诉浏览器，你在下一次重绘之前需要调用这个函数

微任务：process.nexttick(), promise,mutationobserver 这写代码执行便是微任务

为什么要将异步任务分为宏任务和微任务呢？
为了避免宏任务过多，导致某些异步任务（微任务）等待的时间过长，在每个宏任务执行完成之后，
会先将微任务队列中任务执行完毕，再执行下一个宏任务。
因此回调任务队列可以理解为宏任务队列，同时还有另一个微任务队列

在浏览器的异步回调队列中，宏任务和微任务的执行过程如下。
1 宏任务队列中一次只从其中取一个任务执行，执行完了之后去执行微任务队列中的任务
2 微任务队列中的任务都会被取出来执行，知道微任务队列清空
3 在执行完所有的微任务之后，执行下一个宏任务之前，浏览器会进行UI渲染页面，更新界面

在node中事件循环分为6个阶段，上面有，微任务会在事件循环的各个阶段之间执行，


node11以后的事件循环，执行结果与浏览器是一样的吧：
 没错~在 node 11 之后的版本，的确是浏览器保持一致了~ 以 timers 阶段为例，在 node 11 版本之前，只有全部执行了 timers 阶段队列的全部任务才执行微任务队列；在 node 11 版本开始，timer 阶段的 setTimeout、setInterval 被修改为，执行一个任务就立刻执行微任务队列，与浏览器趋同了~


以下
链接：https://juejin.cn/post/6844904106121936903

1。执行同步任务，同步任务不需要做特殊处理，直接执行(下面的步骤中遇到同步任务都是一样处理) --- 第一轮从 script开始
2。从宏任务队列中取出队头任务执行
3。如果产生了宏任务，将宏任务放入宏任务队列，下次轮循的时候执行
4。如果产生了微任务，将微任务放入微任务队列
5。执行完当前宏任务之后，取出微任务队列中的所有任务依次执行
6。如果微任务执行过程中产生了新的微任务，则继续执行微任务，直到微任务的队列为空
轮循，循环以上 2 - 6

总的来说就是：同步任务/宏任务 -> 执行产生的所有微任务(包括微任务产生的微任务) -> 同步任务/宏任务 -> 执行产生的所有微任务(包括微任务产生的微任务) -> 循环......

作者：Horace_
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


console.log("1script start");

setTimeout(() => {
  console.log("8setTimeout");
}, 1000);

Promise.resolve()
  .then(function () {
    console.log("4promise1");
  })
  .then(function () {
    console.log("5promise2");
  });

async function errorFunc() {
  try {
    await Promise.reject("6error!!!");
  } catch (e) {
    console.log("error caught"); // 微1-3
  }
  console.log("2errorFunc");
  return Promise.resolve("errorFunc success");
}
errorFunc().then((res) => console.log("7errorFunc then res"));

console.log("2script end");



setTimeout(()=>{
 console.log(1)
},0)
new Promise((resolve,reject)=>{
 console.log(2)
 setTimeout(()=>{
 console.log(3)
 resolve(4)
 },0)
}).then((val)=>{
 console.log(val)
})
setTimeout(()=>{
 console.log(5)
},0)
console.log(6)
261345

在打印3的下一步，resolve 回调产生一个微任务，放入微任务队列，此时 4 和 5， 4  优先，